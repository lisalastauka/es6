<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>ES6, ES2017</title>
<!-- 
		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab"> -->

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>ES6 & ES7</h1>
					<h3>Overview and features</h3>
					<p>
						<small>Created by <a href="#">Elizabeth Dolgaya</a> <!-- <a href="http://twitter.com/hakimel">@hakimel</a> --></small>
					</p>
				</section>
				<section>
					<h2>JavaScript vs. ECMAScript</h2>
					<ul>
							<li>JavaScript: the language</li>
							<li>ECMAScript: the standard for the language ECMAScript 6 etc.: language versions</li>
						<li>Transpilers (such as Babel) let you compile ES6 to ES5.</li>
					</ul>
				</section>
				<section>
					<h2>ECMAScript Timeline</h2>
					<img src="./timeline.png">
				</section>
				<section>
					<img src="./evolution.fw.png">
				</section>

				<section>
						<h4 >A better language for writing:</h4>
						<ul>
							<li >complex applications;</li>
							<li >libraries (possibly including the DOM) shared by those applications;</li>
							<li >code generators targeting the new edition.</li>

						</ul>					
					</section>
				
			<section>
				<section>
					<h2>ES6 features</h2>
					</section>
					<section>
					<h3>Better syntax for existing features: </h3>
						
						<ul class="fragment">
						<li>Classes</li>
						<li>Modules</li>
						</ul>
					</section>
					<section>	
						
						<h3>New functionality in the standard library:</h3>
							<ul>
								<li>New methods for strings and Arrays</li>
								<li>Promises</li>
								<li>Maps, Sets</li>
							</ul>
						
						</section>
					<section>	
						<h3>New features:</h3>	
							<ul>
								<li>Generators</li>
								<li>Proxies</li>
								<li>WeakMaps</li>
							</ul>
							</section>
	


				</section>

				<section>
					<section>
						<h4>From <a href="#">var</a> to <a href="#">const</a>/<a href="#">let</a></h4>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
var x = 3;
function func(randomize) {
    if (randomize) {
        var x = Math.random(); // (A) scope: whole function
        return x;
    }
    return x; // accesses the x from line A
}
func(false); // undefined
					</code></pre>
					<pre><code class="hljs" data-trim contenteditable>
//In ES6
let x = 3;
function func(randomize) {
    if (randomize) {
        let x = Math.random();
        return x;
    }
    return x;
}
func(false); // 3
					</code></pre>
					</section>
					<section> 
					<h3>Tips:</h3>
					<ul>
						<li>
							<a href="#">Const</a> – for variables whose values never change.
						</li>
						<li>
							<a href="#">Let</a> – for variables whose values do change.
						</li>
						<li>
							Avoid <a href="#">var</a>.
						</li>
						<li>Block scope</li>
						<li>Fresh bindings for a loops</li>
						<li>Clean <a href="">global</a> object</li>
						<li>Redeclaration causes <code>Syntax Error</code></li>
						<li>Invocation before declaration causes <code>Error</code></li>
						<li>TDZ</li>
					</ul>
					
					</section>
					
				</section>
				<section>
						<h4>From IIFEs to blocks</h4>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
(function () {  // open IIFE
    var tmp = ···;
    ···
}());  // close IIFE

console.log(tmp); // ReferenceError
					</code></pre>
					<pre><code class="hljs" data-trim contenteditable>
//In ES6
{  // open block
    let tmp = ···;
    ···
}  // close block

console.log(tmp); // ReferenceError

					</code></pre>
					</section>
					<section>
						<h4>From concatenating to template literals</h4>
						<br>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
function printCoord(x, y) {
    console.log('('+x+', '+y+')');
}
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
function printCoord(x, y) {
    console.log(`(${x}, ${y})`);
}
					</code></pre>
					</section>
					<section>
						<h4>From function expressions to arrow functions</h4>
						<br>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
var arr = [1, 2, 3];
var squares = arr.map(function (x) { return x * x });

					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
const arr = [1, 2, 3];
const squares = arr.map(x => x * x);
					</code></pre>
					</section>
					<section>
						<h4>From <a href="#">for</a> to <a href="#">forEach()</a> to <a href="#">for-of</a></h4>
						
					<pre><code class="hljs" data-trim contenteditable>
//Prior to ES5				
var arr = ['a', 'b', 'c'];
for (var i=0; i < arr.length; i++) {
    var elem = arr[i];
    console.log(elem);
}

					</code></pre>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
arr.forEach(function (elem) {
    console.log(elem);
});

					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
const arr = ['a', 'b', 'c'];
for (const elem of arr) {
    console.log(elem);
}
					</code></pre>
					</section>
					<section>
						<h4>Handling parameter default values</h4>
						<br>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
function foo(x, y) {
    x = x || 0;
    y = y || 0;
    ···
}
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
function foo(x=0, y=0) {
    ···
}
					</code></pre>
					</section>



					
					<section>
						<h4>Exponentiation operator</h4>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
// x ** y is same as Math.pow(x, y) 
const squared = 3 ** 2; 
//9
let num = 3;
num **= 2; 
// same: num = num ** 2 
console.log(num); 
//9
					</code></pre>
					</section>
					<section>
					<section>
					<h3>Spread operator</h3>
						<h4>From <a href="#">arguments</a> to rest parameters</h4>
						<br>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
function logAllArguments() {
    for (var i=0; i < arguments.length; i++) {
        console.log(arguments[i]);
    }
}
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
function logAllArguments(...args) {
    for (const arg of args) {
        console.log(arg);
    }
}
					</code></pre>
					</section>
					<section>
						<h4>From <a href="#"> apply()</a> to the spread operator <a href="#"> (...)</a></h4>
					<p>Math.max()</p>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
> Math.max.apply(Math, [-1, 5, 11, 3])
11
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
> Math.max(...[-1, 5, 11, 3])
11
					</code></pre>
					</section>
					<section>
					<p>Array.prototype.push()</p>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
var arr1 = ['a', 'b'];
var arr2 = ['c', 'd'];

arr1.push.apply(arr1, arr2);
    // arr1 is now ['a', 'b', 'c', 'd']
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
const arr1 = ['a', 'b'];
const arr2 = ['c', 'd'];

arr1.push(...arr2);
    // arr1 is now ['a', 'b', 'c', 'd']
					</code></pre>
					</section>
					

				<section>
						<h4>From <a href="#"> concat()</a> to the spread operator <a href="#"> (...)</a></h4>
					<p>Math.max()</p>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];

console.log(arr1.concat(arr2, arr3));
    // [ 'a', 'b', 'c', 'd', 'e' ]
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

console.log([...arr1, ...arr2, ...arr3]);
    // [ 'a', 'b', 'c', 'd', 'e' ]

					</code></pre>
					</section>
					</section>
					<section>
						<h4>From function expressions in object literals to method definitions</h4>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
var obj = {
    foo: function () {
        ···
    },
    bar: function () {
        this.foo();
    }, // trailing comma is legal in ES5
}
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
const obj = {
    foo() {
        ···
    },
    bar() {
        this.foo();
    },
}
					</code></pre>
					</section>
					<section>
					<section>
						<h4>From constructors to classes</h4>
					<p>Base classes</p>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
function Person(name) {
    this.name = name;
}
Person.prototype.describe = function () {
    return 'Person called '+this.name;
};
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
class Person {
    constructor(name) {
        this.name = name;
    }
    describe() {
        return 'Person called '+this.name;
    }
}
					</code></pre>
					</section>
					<section>
						<p>Derived classes</p>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
function Employee(name, title) {
    Person.call(this, name); // super(name)
    this.title = title;
}
Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
Employee.prototype.describe = function () {
    return Person.prototype.describe.call(this) // super.describe()
           + ' (' + this.title + ')';
};
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
class Employee extends Person {
    constructor(name, title) {
        super(name);
        this.title = title;
    }
    describe() {
        return super.describe() + ' (' + this.title + ')';
    }
}

					</code></pre>
					</section>
					</section>
					<section>
					<h4>From custom error constructors to subclasses of <a href="#"> Error</a></h4>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5				
function MyError() {
    // Use Error as a function
    var superInstance = Error.apply(null, arguments);
    copyOwnPropertiesFrom(this, superInstance);
}
MyError.prototype = Object.create(Error.prototype);
MyError.prototype.constructor = MyError;

function copyOwnPropertiesFrom(target, source) {
    Object.getOwnPropertyNames(source)
    .forEach(function(propKey) {
        var desc = Object.getOwnPropertyDescriptor(source, propKey);
        Object.defineProperty(target, propKey, desc);
    });
    return target;
};
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
class MyError extends Error {
}
					</code></pre>
					
					</section>
					<section>
					<h4>From <a href="#"> objects</a> to <a href="#"> Maps</a></h4>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5
var dict = Object.create(null);
function countWords(word) {
    var escapedWord = escapeKey(word);
    if (escapedWord in dict) {
        dict[escapedWord]++; } else {
        dict[escapedWord] = 1;
    }
}
function escapeKey(key) {
    if (key.indexOf('__proto__') === 0) {
        return key+'%'; } else {
        return key;
    }
}
					</code></pre>
					
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
const map = new Map();
function countWords(word) {
    const count = map.get(word) || 0;
    map.set(word, count + 1);
}
					</code></pre>
					
					</section>
					<section>
					<section>
					<h4>New <a href="#"> string</a> methods </h4>
					<p>From <a href="#">indexOf</a> to <a href="#">startsWith</a>:</p>
					<pre><code class="hljs" data-trim contenteditable>
if (str.indexOf('x') === 0) {} // ES5

if (str.startsWith('x')) {} // ES6
					</code></pre>
					<p>From <a href="#">indexOf</a> to <a href="#">endsWith</a>:</p>
					<pre><code class="hljs" data-trim contenteditable>
function endsWith(str, suffix) { // ES5
  var index = str.indexOf(suffix);
  return index >= 0
    && index === str.length-suffix.length;
}

str.endsWith(suffix); // ES6
					</code></pre>
					
					</section>
					<section>
					<p>From <a href="#">indexOf</a> to <a href="#">includes</a>:</p>
					<pre><code class="hljs" data-trim contenteditable>
if (str.indexOf('x') >= 0) {} // ES5

if (str.includes('x')) {} // ES6
					</code></pre>
<p>From <a href="#">join</a> to <a href="#">repeat</a>:</p>
					<pre><code class="hljs" data-trim contenteditable>
new Array(3+1).join('#') // ES5

'#'.repeat(3) // ES6
					</code></pre>
					</section>
					</section>
					<section>
					<section>
					<h4>New <a href="#"> Array</a> methods </h4>
					<p>From <a href="#">indexOf</a> to <a href="#">findIndex</a>:</p>
					<pre><code class="hljs" data-trim contenteditable>
//In ES5					
const arr = ['a', NaN];

arr.indexOf(NaN); // -1 
arr.findIndex(x => Number.isNaN(x)); // 1
</code></pre>
					<pre><code class="hljs" data-trim contenteditable>
//In ES6					
> isNaN('abc')
true
> Number.isNaN('abc')
false
					</code></pre>
					</section>
					<section>
					<p>From <a href="#">slice</a> to <a href="#">from</a> or the <a href="#">spread</a> operator:</p>
					<pre><code class="hljs" data-trim contenteditable>
var arr1 = Array.prototype.slice.call(arguments); // ES5
const arr2 = Array.from(arguments); // ES6
</code></pre>
					<pre><code class="hljs" data-trim contenteditable>
const arr1 = [...'abc'];
    // ['a', 'b', 'c']
const arr2 = [...new Set().add('a').add('b')];
    // ['a', 'b']
					</code></pre>
					
					</section>
					<section>
					<p>From <a href="#">apply</a> to <a href="#">fill</a>:</p>
					<pre><code class="hljs" data-trim contenteditable>
// Same as Array(undefined, undefined)
var arr1 = Array.apply(null, new Array(2));
    // [undefined, undefined]

const arr2 = new Array(2).fill(undefined);
    // [undefined, undefined]
					</code></pre>

					<pre><code class="hljs" data-trim contenteditable>
// ES5
var arr3 = Array.apply(null, new Array(2))
    .map(function (x) { return 'x' });
    // ['x', 'x']

// ES6
const arr4 = new Array(2).fill('x');
    // ['x', 'x']
					</code></pre>
					</section>
					
					</section>
					<section>
					<h3>ES2017</h3>
					<ul>
						<li>
							<a href="">Major new features</a>:
							<ul>
								<li>Async Functions</li>
								<li>Shared memory and atomics</li>
							</ul>
						</li>
						<li>
							<a href="">Minor new features</a>:	
							<ul>
								<li>Object.values/Object.entries</li>
								<li>String padding </li>
								<li>Object.getOwnPropertyDescriptors()</li>
								<li>Trailing commas in function parameter lists and calls</li>
							</ul>
						</li>
					</ul>
					
					
					

					</section>
					<section>
						<section>
							<h3>Async Functions</h3>
						Variants:

						<p>Async function <a href="">declarations</a>: </p>
						<pre><code class="hljs" data-trim contenteditable> async function foo() {}</code></pre>
						Async function <a href="">expressions</a>: 
<pre><code class="hljs" data-trim contenteditable>const foo = async function () {};</code></pre>
<p>Async  <a href="">method definitions</a>:</p>
 
<pre><code class="hljs" data-trim contenteditable>let obj = { async foo() {} }</code></pre>
<p>Async <a href="">arrow</a> functions: </p>

<pre><code class="hljs" data-trim contenteditable>const foo = async () => {};</code></pre>


						
						</section>
						<section>
							<p><a href="">Async</a> functions always return <a href="">Promises</a> </p>

Fulfilling the <a href="">Promise</a> of an <a href="">async</a> function:
<pre><code class="hljs" data-trim contenteditable>
async function asyncFunc() {
    return 123;
}

asyncFunc()
.then(x => console.log(x));
    // 123</code></pre>
Rejecting the <a href="">Promise</a> of an <a href="">async</a> function:
<pre><code class="hljs" data-trim contenteditable>
async function asyncFunc() {
    throw new Error('Problem!');
}

asyncFunc()
.catch(err => console.log(err));
    // Error: Problem!
</code></pre>
						</section>
					</section>
					<section>
					<section>
					<h3>Shared memory and atomics</h3>
					
							<p>Shared Array Buffers</p>
							<ul>
							<li>A primitive building block for higher-level concurrency abstractions</li>
								<li>You can share data between workers more quickly.</li>
								<li>Coordination between workers becomes simpler and faster (compared to postMessage()).</li>
								<li>Let’s you compile threaded C++ code to JavaScript</li>
							</ul>
					</section>
					<section>
						<h3>Problems:</h3>
						<ul>
							<li>compilers may rearrange reads</li>
							<li>writes may be reordered</li>
						</ul>
					</section>
					<section>
					<h3>Atomics</h3>
					<p>Atomics ensures:</p>
					<ul><li>Operations are non-interruptible (atomic) – think transactions in DBs</li>
<li>Order of writes and reads is fixed</li>
<li> No reads or writes get eliminated</li>
<li>Can be used to synchronise non-atomic reads and writes</li></ul>
					
					</section>
					</section>
					<section>
					<h3>Object.entries()</h3>
							<p>Returns an Array of  <code>[key,value]</code> pairs: </p>
 
<pre><code class="hljs" data-trim contenteditable>

> Object.entries({ one: 1, two: 2 })
[ [ 'one', 1 ], [ 'two', 2 ] ]</code></pre>

Easier to iterate over properties:

<pre><code class="hljs" data-trim contenteditable>
const obj = { one: 1, two: 2 };
for (const [k, v] of Object.entries(obj)) {
    console.log(k, v);
}
// Output
// "one" 1
// "two" 2
</code></pre>

						</section>
						<section>
					<h3>Object.values()</h3>
							<p>Complements <a href="">Object.keys()</a> and <a href="">Object.entries()</a>:</p>
 
<pre><code class="hljs" data-trim contenteditable>

> Object.values({ one: 1, two: 2 })
[ 1, 2 ]</code></pre>

						</section>
						<section>
							<h2>Thanks!</h2>
							<img src="./QUESTIONS.jpg">

						</section>


			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
